# 光纤告警监控系统

这是一个基于C++的光纤告警监控系统，用于实时监控光纤链路状态并根据告警情况动态更新光纤颜色。

## 项目功能

- 实时接收和处理光纤端口告警信息
- 根据告警级别和类型更新光纤颜色状态
- 支持多端口光纤链路的告警聚合
- 基于任务分组的多线程告警处理
- 线程安全的数据结构管理

## 核心组件

### 1. 数据结构定义 (CommonStruck.h)
- **FiberColor**：光纤颜色枚举（红色、黄色、绿色）
- **PortNode**：端口节点结构（板卡ID和端口键）
- **Fiber**：光纤链路结构（链路ID和端口节点列表）
- **AlarmLevel**：告警级别枚举（红色告警、黄色告警）
- **AlarmType**：告警类型枚举（发送告警、清除告警）
- **AlarmNode**：告警节点结构（端口节点、告警级别、告警类型）

### 2. 主程序逻辑 (FiberColor.cpp)
- **告警处理**：接收、缓存、清除和处理告警信息
- **光纤状态更新**：根据告警情况动态更新光纤颜色
- **线程池管理**：基于任务分组的多线程设计，同一链路的告警处理分配到同一个队列
- **数据结构管理**：维护端口到光纤的映射、端口到告警级别的映射、链路ID到颜色的映射

### 3. 链路管理 (LinkHandle)
- 获取所有链路信息
- 管理光纤链路的基本信息

### 4. 告警管理 (AlarmHandle)
- 告警线程处理
- 告警回调函数注册

## 实现逻辑

### 1. 初始化流程
1. 初始化光纤映射（从LinkHandle获取所有链路信息）
2. 创建线程池（默认4个线程）
3. 启动告警监听线程

### 2. 告警处理流程
1. 接收告警信息（MyAlarmCallback）
2. 根据链路ID分配到固定队列（基于哈希函数）
3. 缓存或清除告警信息（CacheAlarmNode / ClearAlarmNode）
4. 处理告警并更新光纤颜色（ProcessAlarmNode）
5. 报告光纤颜色变化（ReportMsg）

### 3. 光纤颜色更新规则
- **单端口光纤**：根据端口的最高告警级别设置颜色
  - 红色告警：光纤为红色
  - 黄色告警：光纤为黄色
  - 无告警：光纤为绿色

- **多端口光纤**：根据所有端口的告警情况设置颜色
  - 所有端口都有红色告警：光纤为红色
  - 有任何端口有黄色告警：光纤为黄色
  - 无告警：光纤为绿色

### 4. 线程池设计
- 使用任务分组设计，同一链路的告警处理分配到同一个队列
- 确保同一链路的告警处理顺序执行
- 使用互斥锁保护共享数据访问
- 支持线程安全的任务添加和处理

## 编译和运行

```bash
# 编译
g++ -std=c++11 -pthread FiberColor.cpp LinkHandle.cpp AlarmHandle.cpp -o FiberColor

# 运行
./FiberColor
```

## 输出示例

```
Port Node: (1, port1) Alarm Type: SEND_ALARM, Alarm Level: RED
Link ID: 1, Fiber Color set to: RED
Port Node: (1, port1) Alarm Type: CLEAR_ALARM, Alarm Level: RED
Link ID: 1, Fiber Color changed from: RED to: GREEN
```

## 技术特点

- 使用C++11线程库实现多线程处理
- 基于任务分组的线程池设计，提高处理效率
- 线程安全的数据结构管理
- 清晰的模块化设计，便于扩展和维护
- 实时告警处理和状态更新